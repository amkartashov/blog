var store = [{
        "title": "Welcome to Jekyll!",
        "excerpt":"You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.   To add new posts, simply add a file in the _posts directory that follows the convention YYYY-MM-DD-name-of-post.ext and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.   Jekyll also offers powerful support for code snippets:   def print_hi(name)   puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT.  Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.   ","categories": ["jekyll","update"],
        "tags": [],
        "url": "https://blog.gorilych.ru/jekyll/update/welcome-to-jekyll/",
        "teaser": null
      },{
        "title": "Pulumi for Terraform users",
        "excerpt":"This article is intended for engineers familiar with IaC, modern IaC tools, and related terminology. As title suggests, it might be interesting for Terraform users - I’ll try to compare Terraform and Pulumi. The article is based on personal experience and may appear opinionated.   IaC approach         IaC workflow   I am sure Terraform users have correct understanding of what IaC is and is not, but for the sake of article consistency, let me repeat it here.   Infrastructure as Code aims to provide a reliable, repeatable, and automatic way to create, adjust, or destroy infrastructure components or resources. Usually these are networking, compute, or storage resources in public clouds like AWS.   The major concept and the main difference with manual administration is that you describe infrastructure in a declarative way. Code part means that this description is machine-readable and a machine executes the code to operate infrastructure.   Another pillar in IaC is a concept of State  - description of operated resources with their actual conditions and characteristics. A state can be either stored somewhere or calculated each time (in ansible, f.e.). IaC requires state in its workflow because it should work with the same set of resources during infrastructure lifetime.   Usually we use specific tool for IaC (CloudFormation, Terraform, Pulumi, Ansible, etc). I would say it’s another concept behind IaC, implicit though. Of course, you can also manage resources programmatically with cloud API using regular scripts. But with these requirements of having state and describe infrastructure declaratively you’ll end up with writing your own IaC tool.   In short, IaC workflow is to write some code and use specific IaC tool to execute it, producing state and cloud resources as a result.   What is Pulumi   Pulumi is a modern IaC tool that essentially differs from others by allowing the use of real programming languages. This doesn’t mean it uses an imperative approach though because a code describes a desired state and not API calls or procedures to perform.   Currently supported language runtimes are Node.js, Python, .NET Core, and Go.   Let’s outline the main terms of Pulumi’s architecture (described in greater detail in Architecture &amp; Concepts).      Project - the code itself which describes cloud resources - directory containing collection of program files (*.go, *.ts etc) and a metadata file Pulumi.yaml   Stack - instance of a Project, collection of cloud resources deployed with particular Configuration (see below). F.e., you may have separate stacks for production and staging environments.   Stack Configuration - YAML file with a set of values which are used to modify operation flow. This adds flexibility so you can re-use the same Project for environments with distinct DNS names, different compute power and storage capacity and so on. Configuration file is named after a Stack as Pulumi.&lt;stack-name&gt;.yaml.   Stack State - state of cloud resources in a Stack.   Stack Output - calculated values which are known after deployment, f.e. EC2 instance id, generated password for RDS, etc   These terms are close but not always interchangeable with Terraform ones. Pulumi’s project is close to Terraform’s root module. Terraform’s workspace is a close concept for Pulumi’s stack. Output and configuration can be considered the same.   Likewise in Terraform, there is a specific binary pulumi to execute Pulumi programs. pulumi is used to operate state backends (a place where state files are stored) and stacks.   How Pulumi works   When you run a pulumi program it is executed with pulumi binary. Pulumi engine computes a desired state from resources registered by the program and then creates, updates, or deletes resources as needed.   Pulumi consists of a language host that is responsible for executing the code and deployment engine which is responsible for interacting with cloud API.   For the greater details refer to these articles:     https://www.pulumi.com/docs/intro/concepts/how-pulumi-works/   https://www.pulumi.com/docs/intro/concepts/programming-model/   Programming model  Code example  Code reuse  CLI usage  Pulumi vs Terraform  Conclusion  References  ","categories": [],
        "tags": ["pulumi","terraform"],
        "url": "https://blog.gorilych.ru/pulumi-for-tf-users/",
        "teaser": null
      }]
